---
title: "Práctica 1"

categories:
  - Weekly Log
tags:
  - github pages
  - ROS
  - ROS2
  - Robótica de servicio
---

# Localized Vacuum Cleaner

## Idea principall del algoritmo
1. Se deberá autolocalizar el robot para que sepa su posición actual.
2. Descomposición del mapa 
3. Aplicar dilatación a obstáculos
4. Viaje entre nodos.


## Semana 1: 09-10-2023 a 15-10-20023
Se planteó abordar el problema con una máquina de estados:

<figure class="align-center" style="width:50%">
  <img src="{{ site.url }}{{ site.baseurl }}/assets/images/post1/maquinaEstados.png" alt="">
  <figcaption>Infraestructura básica</figcaption>
</figure>

### Get path
Se encargará de obtener la imagen del mapa, dividir el mapa en celdas y conseguir el camino más óptimo para recorrer todas las celdas.

#### Algoritmo BSA
El algoritmo para limpiar consistirá en poder desplazarse en 4 sentidos: norte, este, sur, oeste. El orden es importante, ya que si una celdilla está libre en la dirección del primero, el robot avanzará en esa dirección; si no, pasará a la siguiente.

#### Representación del mapa: 
Se dividirá el mapa en rejillas, se creará una matriz de forma que grid[X][Y] = estado. El estado marcará si la celdilla es un obstáculo, ya ha sido recorrida o si está libre. Se deben destacar cuatro tipos de celdas:
* Obstáculos
* Obstáculos virtuales (El robot ya pasó por esa coordenada)
* Puntos de retorno 
* Puntos críticos (Todas las celdillas de alrededor son obstáculos)

Al principio se manejó la idea de 3 listas donde se almacenarán obstáculos, obstáculos virtuales y puntos de retorno, pero al estar comprobando constantemente todas las listas, me di cuenta de que era mucho más efectivo tener una lista de ese tipo solo para los puntos de retorno.


#### Recuperación en puntos críticos
A medida que el robot se mueve, se va guardando en una pila los puntos de retorno; una vez que se llegue al punto crítico, se volverá al último punto guardado en la pila. Este camino de vuelta se calculará con descenso por gradiente reutilizando la [Práctica 4](https://portanova2002.wixsite.com/robotica-movil) del año pasado.

#### Desarrollo fuera de unibotics
Para desarrollar esta parte, se utilizó el mapa y OpenCV, desarrollando un pequeño visualizador para el algoritmo.

<figure class="align-center" style="width:70%">
  <img src="{{ site.url }}{{ site.baseurl }}/assets/images/post1/visualizador.png" alt="">
  <figcaption>Visualizador openCV</figcaption>
</figure>

* **Punto rosa**: Aspiradora.
* **Celdas azul oscuro**: Celdas visitadas.
* **Celdas azul grisaceo**: Celdas visitadas con el algoritmo de retorno.
* **Celdas amarillas**: Punto retorno al que se está desplazando la aspiradora.


### Turn
Para el giro reutilizaremos código de la misma práctica; aquí podemos resaltar los siguientes aspectos:
* "Lo más complicado fué calcular la velocidad angular, para saber en que dirección ir. Se calculaba la arcotangente del
 siguiente punto de la ruta respecto a la posición del coche. Este valor tenía un rango entre -pi y pi, se pasó este rango de 0 a 2pi, lo mismo se hizo con la yaw del coche. "

 * "Por último se restaron ambos valores y aplicando una conversión de este valor con la máxima velocidad angular 
deseada, conseguimos un comportamiento satisfactorio en el coche"

Al tener estos cálculos encapsulados en una función, lo único que se hizo fue añadir un pequeño PD para que al principio el robot no tenga una sobrerespuesta, pero a medida que se acerque a la orientación indicada vaya reduciendo velocidad hasta llegar a la posición deseada con un error de 0.01.




