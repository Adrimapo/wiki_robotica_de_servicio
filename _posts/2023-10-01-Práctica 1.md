---
title: "Práctica 1"

categories:
  - Weekly Log
tags:
  - github pages
  - ROS
  - ROS2
  - Robótica de servicio
---

# Localized Vacuum Cleaner

## Idea principall del algoritmo
1. Se deberá autolocalizar el robot para que sepa su posición actual.
2. Descomposición del mapa 
3. Aplicar dilatación a obstáculos
4. Viaje entre nodos.


## Semana 1: 02-10-2023 a 8-10-2023
Se planteó abordar el problema con una máquina de estados:

<figure class="align-center" style="width:50%">
  <img src="{{ site.url }}{{ site.baseurl }}/assets/images/post1/maquinaEstados.png" alt="">
  <figcaption>Infraestructura básica</figcaption>
</figure>

### Get path
Se encargará de obtener la imagen del mapa, dividir el mapa en celdas y conseguir el camino más óptimo para recorrer todas las celdas.

#### Algoritmo BSA
El algoritmo para limpiar consistirá en poder desplazarse en 4 sentidos: norte, este, sur, oeste. El orden es importante, ya que si una celdilla está libre en la dirección del primero, el robot avanzará en esa dirección; si no, pasará a la siguiente.

#### Representación del mapa: 
Se dividirá el mapa en rejillas, se creará una matriz de forma que grid[X][Y] = estado. El estado marcará si la celdilla es un obstáculo, ya ha sido recorrida o si está libre. Se deben destacar cuatro tipos de celdas:
* Obstáculos
* Obstáculos virtuales (El robot ya pasó por esa coordenada)
* Puntos de retorno 
* Puntos críticos (Todas las celdillas de alrededor son obstáculos)

Al principio se manejó la idea de 3 listas donde se almacenarán obstáculos, obstáculos virtuales y puntos de retorno, pero al estar comprobando constantemente todas las listas, me di cuenta de que era mucho más efectivo tener una lista de ese tipo solo para los puntos de retorno.


#### Recuperación en puntos críticos
A medida que el robot se mueve, se va guardando en una pila los puntos de retorno; una vez que se llegue al punto crítico, se volverá al último punto guardado en la pila. Este camino de vuelta se calculará con descenso por gradiente reutilizando la [Práctica 4](https://portanova2002.wixsite.com/robotica-movil) del año pasado.

#### Desarrollo fuera de unibotics
Para desarrollar esta parte, se utilizó el mapa y OpenCV, desarrollando un pequeño visualizador para el algoritmo.

<figure class="align-center" style="width:70%">
  <img src="{{ site.url }}{{ site.baseurl }}/assets/images/post1/visualizador.png" alt="">
  <figcaption>Visualizador openCV</figcaption>
</figure>

* **Punto rosa**: Aspiradora.
* **Celdas azul oscuro**: Celdas visitadas.
* **Celdas azul grisaceo**: Celdas visitadas con el algoritmo de retorno.
* **Celdas amarillas**: Punto retorno al que se está desplazando la aspiradora.


### Turn
Para el giro reutilizaremos código de la misma práctica; aquí podemos resaltar los siguientes aspectos:
* "Lo más complicado fué calcular la velocidad angular, para saber en que dirección ir. Se calculaba la arcotangente del
 siguiente punto de la ruta respecto a la posición del coche. Este valor tenía un rango entre -pi y pi, se pasó este rango de 0 a 2pi, lo mismo se hizo con la yaw del coche. "

 * "Por último se restaron ambos valores y aplicando una conversión de este valor con la máxima velocidad angular 
deseada, conseguimos un comportamiento satisfactorio en el coche"

Al tener estos cálculos encapsulados en una función, lo único que se hizo fue añadir un pequeño PD para que al principio el robot no tenga una sobrerespuesta, pero a medida que se acerque a la orientación indicada vaya reduciendo velocidad hasta llegar a la posición deseada con un error de 0.01.


## Semana 2: 09-10-2023 a 15-10-2023
### Forward 
Para implementar el movimiento hacia delante, se utilizó también un PID junto a una tolerancia de llegada al objetivo. El error se ajustó para cada dirección con el propósito de añadir robustez al código y que en caso de que la aspiradora se pasase del punto al que se quiere ir pudiera retornar.

### Obtención de imagen 
Para la obtención de imagen se utilizó la librería urllib para que la función funcionara tanto para unibotics como para las pruebas locales. 

### Clases
Para mejorar la estructura del programa se crearon 2 clases una para el path planning y otra para la aspiradora.

### Optimización de ruta
Se añadió una función en el pathplanner para que si había que avanzar 3 casillas distintas en la misma dirección, solo se guarde la coordenada de la última lo que facilitará mucho el cálculo de distancia y el uso del PID en la velocidad lineal.

### Get next point
El estado de get next point consiste en obtener de la lista de la ruta el punto actual y el siguiente, para girar antes de que se llegue a la posición en el desplazamiento en línea y se elimina el último punto adquirido. Además devolverá la dirección donde se avanza al punto para facilitar el giro.

### Localización
Para la localización se tomaron varios puntos en el mapa y por regresión lineal se calcularon las transformaciones necesarias para pasar del mundo real al mapa 3D.

<!-- Insertar imágenes de la regresión lineal -->

## Seamana 3: 15-10-20023 a 22-10-2023

<!-- ### Muestra de la imagen en unibotics
Para la depuración se creó una función que mostrara la siguiente posición en unibotics. -->

### Giro suavizado
Se implementó en la velocidad que antes de que llegara al punto el robot gire hacia la siguiente dirección.


### Error en posición
Al calcular los puntos de la regresión lineal, me dí cuenta de que había un error en la posición. Al principio pensé que era proporcional al tiempo por lo que calculé la cumulación de error de cada compmente cada segundo, para poder compensarlo en la clase de la aspiradora. El problema vino al descubrir que el error no era lineal respectoal tiempo por lo que aunque esta técnica mitigara el efecto, el error seguía siendo suficiente como para poder hacer a la aspiradora chocarse.

### Error en posición 2
Como segunda posibles maneras de solucionar el problema se me ocurrió:
1. Algoritmo VFF donde se aleje de las paredes. Pero esto podría hacer que los puntos se vayan desplazando poco a poco hasta perderse y no poder llegar al punto deseado.

2. Test del cuadrado para ajustar posición.

3. Algoritmo de autolocalización: Ya que disponemos del laser, podríamos guardar la posición estimada de los obstáculos próximos en el mapa, desde nuestro punto actual, comparando la distancia al obstáculo en el mapa y usando el laser para obtener la distancia real, podriamos calcular el error en cada momento y actualizar la posición para que el robot esté bien localizado. 

### Autolocalización
Optaremos por la tercera opción, una posible implementación podría ser usando la función get_next_point, calcularemos los obstáculos mas cercanos en un umbral y en direcciones concretas (norte, sur, este, oeste). Una vez llegada a la posición calcularemos el error que tiene acumulado el robot y lo restaremos, para que así el robot corriga el error  de una manera dinámica, además como el error temportal tuvo resultados favorables a no tener nada, combinaremos ambas técnicas para que si en algún punto el robot no detecta obstáculos en su umbral, el error se vaya corrigiendo poco a poco.

### Modelo probabilístico de observación sensorial
Tendremos el mapa 2D que nos proporcionará la posición de los obtáculos y las lecturas del laser que ajustarán la posición del robot.

### Fusión robabilística
Se irá actualizando la posición del robot calculando el error acumulado hasta que se llegue a un punto y este error se sumará al total de la posición paulatinamente.